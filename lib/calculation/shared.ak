//// Shared types and functions across all pool calculations

use aiken/builtin
use aiken/math

/// An interim pool state
// NOTE: we don't actually use this type
// because passing individual parameters is way more efficient
// but an earlier version used this, and it's useful for documentation
// pub type PoolState {
  // The quantity of token A in the pool
  // quantity_a: SingletonValue,
  // The quantity of token B in the pool
  // quantity_b: SingletonValue,
  // The quantity of LP tokens in the pool
  // quantity_lp: SingletonValue,
//}

pub fn unsafe_fast_index_skip_with_tail(inputs: List<a>, idx: Int) -> List<a> {
  if idx >= 15 {
    unsafe_fast_index_skip_with_tail(
      inputs
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list,
      idx - 15,
    )
  } else if idx >= 7 {
    unsafe_fast_index_skip_with_tail(
      inputs
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list
        |> builtin.tail_list,
      idx - 7,
    )
  } else {
    unsafe_fast_index_with_tail(inputs, idx)
  }
}

fn unsafe_fast_index_with_tail(inputs: List<a>, idx: Int) -> List<a> {
  if idx == 0 {
    inputs
  } else {
    unsafe_fast_index_with_tail(builtin.tail_list(inputs), idx - 1)
  }
}

pub fn check_and_set_unique(uniqueness_flags: Int, index: Int) -> Int {
  expect index >= 0
  let bit = do_2_exp(index)
  let bit_shifted = 2 * bit

  let flag_set = uniqueness_flags + bit

  expect flag_set % bit_shifted > uniqueness_flags % bit_shifted
  flag_set
}

pub fn do_2_exp(e: Int) -> Int {
  let a = #[1, 2, 4, 8, 16, 32, 64, 128]
  if e < 8 {
    builtin.index_bytearray(a, e)
  } else if e < 16 {
    256 * builtin.index_bytearray(a, e - 8)
  } else if e < 24 {
    65536 * builtin.index_bytearray(a, e - 16)
  } else if e < 32 {
    16777216 * builtin.index_bytearray(a, e - 24)
  } else if e < 40 {
    4294967296 * builtin.index_bytearray(a, e - 32)
  } else {
    math.pow2(e)
  }
}
